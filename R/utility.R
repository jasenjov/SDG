
#' Performance data generation according to independent probabilities of success. Linear model.
#'
#' This function generates students' performance data without considering neither a skills per student matrix nor a Q-Matrix. \cr
#' All the students are answering to all the items according to a [0-1] students per items matrix where each element represents the probability of the student i to succeed the item j.
#' The mentioned matrix (students x items) is generated by default according to the normal distribution with a mean of 0 and a standard deviation of 1. \cr
#' The user can modify those parameters. However, the user can also introduce the matrix by himself. 
#'
#' @param its Number of items.
#' @param sts Number of students.
#' @param success.prob.matrix Matrix with dimension students*items. Each value represents the probability of a student i to success the item j.[0-1] matrix. NULL by default
#' @param mean If the success.prob.matrix is not provided to the function, this parameter is the mean used to generate that matrix according to the standard distribution (normalized afterwards between 0 and 1). 0 by default.
#' @param deviation If the success.prob.matrix is not provided to the function, this parameter is the normal deviation used to generate that matrix according to the standard distribution (normalized afterwards between 0 and 1). 1 by default.
#'
#' @return A list with the following information:
#'  \item{results}{Students per items matrix where each element represents if the student answered correctly (1) or not (0) to the correspondent item.}
#'  \item{success.prob.matrix}{A student per item matrix where each element represents the probability of a student to answer correctly to the correspondent item.}
#'  
#'  @seealso 
#'  \code{\link{successProbGen}} for the external generation of a student per item probability of success matrix.
#'  \cr
#'  @examples 
#'  ##### EXAMPLE 1 : Generation just introducing the number of items and students #####
#'  
#'  # We generate student performance data about 3 students answering to 5 items
#'  result <- randGen(its = 5, sts = 3) 
#'  
#'  # We extract the correspondent information
#'  
#'  performance <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    1    1    0
#'  [2,]    1    1    1    0    1
#'  [3,]    1    0    1    0    0
#'  
#'  success.probabilities <- result$success.prob.matrix
#'  success.probabilities 
#'          [,1]       [,2]      [,3]      [,4]      [,5]
#'  [1,] 0.01231753 0.90747166 0.4095728 0.9999342 0.2118582
#'  [2,] 0.68874955 0.81822425 0.6833268 0.8773570 0.7834774
#'  [3,] 0.73083892 0.02549496 0.7293477 0.2291466 0.4035640
#'  
#'  
#'  ###EXAMPLE 2 : Generation modeling the mean and standard deviation of the standard distribution##
#'  
#'  # We generate student performance data about 3 students answering to 5 items with a mean of 0.5 \cr
#'  
#'  and a standard deviation of 0.2.
#'  result <- randGen(its = 5, sts = 3,mean = 0.5,deviation=0.2)
#'  
#'  # We extract the correspondent information
#'  
#'  performance  <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    1    1    1    1    1
#'  [2,]    1    1    1    1    0
#'  [3,]    1    1    0    1    0
#'
#'  success.probabilities <- result$success.prob.matrix
#'  success.probabilities
#'          [,1]      [,2]      [,3]      [,4]      [,5]
#'  [1,] 0.8237951 0.6739213 0.7073844 0.7008126 0.7444546
#'  [2,] 0.5642406 0.6735758 0.7183799 0.6911244 0.5717511
#'  [3,] 0.7246194 0.8351532 0.6331505 0.6782793 0.6518936
#'  
#'  
#'  ##### EXAMPLE 3 : Generation providing the student per item success probability matrix #####
#'  
#'  # We first generate the desired matrix
#'  prob.success  <- successProbGen(its = 5, sts = 3)
#'  prob.success
#'          [,1]      [,2]      [,3]      [,4]      [,5]
#'  [1,] 0.3788828 0.6811485 0.7916251 0.4924259 0.7644050
#'  [2,] 0.6076803 0.7911027 0.9229351 0.9763337 0.4992891
#'  [3,] 0.9118014 0.9351249 0.7218492 0.7246330 0.8756847
#'  
#'  # We generate student performance data about 3 students answering to 5 items according to a \cr
#'  given matrix.
#'  result <- randGen(its = 5, sts = 3,success.prob.matrix = prob.success)
#'  
#'  # We extract the correspondent information
#'  
#'  performance <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    1    0    1
#'  [2,]    0    1    1    1    0
#'  [3,]    1    1    1    0    1
#'  
#'  success.probabilities  <- result$success.prob.matrix
#'  # We expect the same as provided
#'  success.probabilities
#'          [,1]      [,2]      [,3]      [,4]      [,5]
#'  [1,] 0.3788828 0.6811485 0.7916251 0.4924259 0.7644050
#'  [2,] 0.6076803 0.7911027 0.9229351 0.9763337 0.4992891
#'  [3,] 0.9118014 0.9351249 0.7218492 0.7246330 0.8756847
#
randGen <- function(its,sts,success.prob.matrix=NULL,mean=0,deviation=1){
  if(is.null(success.prob.matrix)){
    mx <- successProbGen(its,sts,mean=mean,deviation=deviation)
  }
  else{
    mx <- success.prob.matrix
  }
  mx.s <- matrix(sapply(mx, function(i){ sample(0:1, 1,   prob=c(1-i,  i))}), sts, its)
  results <- list(mx.s,mx)
  names(results) <- c('results','success.prob.matrix')
  return(results)
}




#' Performance data generation according to a pessimistic approach. Linear model.
#'
#' This function generates students' performance data according to a Q-matrix sampling model where more than one skill can be required to succeed an item. \cr
#' Given a number of skills involved in the set of items, there is a matrix in which each element represents the probability of a student to suceed an item involving a specific skill. It's a students per skills matrix (skills matrix).It is formed by [0-1] values.  \cr
#' So, if an item requires 2 skills, the probability of a student to answer correctly to that item will be the minimum between the probabilities of this student to succeed items involving those skills (skills matrix).
#'
#' @param its Number of items.
#' @param sts Number of students.
#' @param rank Number of skills the set of items has.
#' @param q Q-Matrix representing the skills required to succeed an item. Skills per item matrix. \{0,1\} values. NULL by default.
#' @param skills Matrix representing the probability of each student to answer correctly to an item involving a specific skill. students per skills matrix.[0-1] values. NULL by default.
#' @param mean If the skills matrix is not provided to the function, this parameter is the mean used to generate that matrix according to the standard distribution. 0 by default.
#' @param deviation If the skills matrix is not provided to the function, this parameter is the standard deviation used to generate that matrix according to the standard distribution. 1 by default.
#' 
#' @return A list with the following information:
#'  \item{results}{Students per items matrix where each element represents if the student answered correctly (1) or not (0) to the correspondent item.}
#'  \item{skills.matrix}{A student per skill matrix where each element represents the probability of a student to answer correctly to an item that involves the correspondent skill.}
#'  \item{q.matrix}{The Q-matrix used.}
#'  
#' @seealso 
#'  \code{\link{QgenInc}} for the external generation of a Q-matrix.\cr
#'  \code{\link{QgenReg}} for the external generation of a Q-matrix.\cr
#'  \code{\link{extendQ}} for the external generation of a Q-matrix.\cr
#'  \code{\link{reduceQ}} for the external generation of a Q-matrix.\cr
#'  \code{\link{skillsGen}} for the external generation of the skills matrix.\cr
#'  
#' @examples
#' 
#'  #####EXAMPLE 1 : Generation introducing the minimum number of parameters required #####
#'  
#'  # We generate student performance data about 3 students answering to 5 items and 3 skills.
#'  result <- minGen(its = 5, sts = 3, rank = 3)
#'  
#'  # We extract the correspondent information
#'  
#'  performance  <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    1    0    1
#'  [2,]    1    1    0    1    1
#'  [3,]    1    0    0    0    0
#'  
#'  skills  <- result$skills.matrix
#'  skills
#'          [,1]      [,2]      [,3]
#'  [1,] 0.6760280 0.6686970 0.5695697
#'  [2,] 0.5326328 0.7144692 0.9995925
#'  [3,] 0.3629950 0.6258358 0.9310147
#'  
#'  q.matrix  <- result$q.matrix
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    1    1    1
#'  [2,]    1    1    0    1    0
#'  [3,]    1    0    0    1    0
#'
#' #####EXAMPLE 2 : Generation modeling the mean and the standard deviation used #####
#' 
#'  # We generate student performance data about 3 students answering to 5 items and 3 skills.
#'  #For the stantard distribution (skills matrix), we use a mean of 0.5 and a standard
#'  deviation of 0.2.
#'  result <- minGen(its = 5, sts = 3, rank = 3,mean=0.5,deviation=0.2)
#'  
#'  # We extract the correspondent information
#'  
#'  performance  <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    1    0    0
#'  [2,]    1    0    0    1    0
#'  [3,]    1    1    1    1    0
#'  
#'  skills  <- result$skills.matrix
#'  skills
#'          [,1]      [,2]      [,3]
#'  [1,] 0.7211562 0.6510095 0.7547658
#'  [2,] 0.6853259 0.7352926 0.6736784
#'  [3,] 0.7387059 0.6182576 0.6575972
#'  
#'  q.matrix  <- result$q.matrix
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    1    0    0    0    0
#'  [2,]    0    1    1    1    1
#'  [3,]    0    0    0    0    0
#' 
#'  #####EXAMPLE 3 : Generation introducing a Q-matrix #####
#'
#'  #We generate a Q-Matrix with 3 skills involved.
#'  q.matrix <- QgenInc(num.skills = 3,maxSkillsPerItem=2)
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    1    0    0    1    1    0
#'  [2,]    0    1    0    1    0    1
#'  [3,]    0    0    1    0    1    1
#'  
#' # We generate student performance data about 3 students answering to 6 items, 3 skills and 
#' the Q Matrix we want.
#' # For the stantard distribution (skills matrix), we use a mean of 0.5 and a standard 
#' deviation of 0.2.
#'  result <- minGen(its = 6, sts = 3, rank = 3,q = q.matrix,mean=0.5,deviation=0.2)
#'
#'  # We extract the correspondent information
#'
#'  performance  <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    0    0    0    1    1    0
#'  [2,]    1    1    1    0    0    1
#'  [3,]    1    1    0    1    1    0
#'  skills  <- result$skills.matrix
#'  skills
#'          [,1]      [,2]      [,3]
#'  [1,] 0.6868604 0.6387136 0.6409983
#'  [2,] 0.5920339 0.6761624 0.6858127
#'  [3,] 0.7560064 0.6037571 0.5528284
#'  q.matrix  <- result$q.matrix
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    1    0    0    1    1    0
#'  [2,]    0    1    0    1    0    1
#'  [3,]    0    0    1    0    1    1
#' 
#'  #####EXAMPLE 4 : Generation introducing a Q-Matrix and a skills matrix #####
#'  
#'  #We generate a Q-Matrix with 3 skills involved.
#'  q.matrix <- QgenInc(num.skills = 3,maxSkillsPerItem=2)
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    1    0    0    1    1    0
#'  [2,]    0    1    0    1    0    1
#'  [3,]    0    0    1    0    1    1
#'  
#'  #We generate a skills matrix  skills for 3 students, 3 skills, a mean of 0 and a standard 
#'  deviation of 1.
#'  skills  <- skillsGen(sts = 3,mean = 0,deviation = 1,rank = 3)
#'  skills
#'          [,1]      [,2]      [,3]
#'  [1,] 0.38186877 0.5632612 0.6603963
#'  [2,] 0.02718055 0.2536993 0.2962467
#'  [3,] 0.60535135 0.9708733 0.5421141
#'  
#'  # We generate student performance data about 3 students answering to 6 items, 3 skills and 
#'  the Q Matrixand skills matrix we want.
#'  result <- minGen(its = 6, sts = 3, rank = 3,q = q.matrix,skills = skills)
#'  
#'  performance  <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    0    0    0    1    0    1
#'  [2,]    0    0    0    0    1    1
#'  [3,]    0    1    1    1    0    1
#'  
#'  skills  <- result$skills.matrix
#'  skills
#'          [,1]      [,2]      [,3]
#'  [1,] 0.38186877 0.5632612 0.6603963
#'  [2,] 0.02718055 0.2536993 0.2962467
#'  [3,] 0.60535135 0.9708733 0.5421141
#'  
#'  q.matrix  <- result$q.matrix
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    1    0    0    1    1    0
#'  [2,]    0    1    0    1    0    1
#'  [3,]    0    0    1    0    1    1
#'
#
minGen <- function(its,sts,rank,q = NULL,skills=NULL,mean=0,deviation=1){
  if(is.null(skills)){
    skills <- skillsGen(sts=sts,mean=mean,deviation=deviation,rank=rank)
  }
  if(is.null(q)){
    q <- QgenInc(rank,rank)
    if(its < ncol(q)){
      q <- reduceQ(q,its)
    }
    else if(its > ncol(q)){
      q <- extendQ(q,(its-ncol(q)))
    }
  }
  mx <- sapply(1:its,function(x){sapply(1:sts,function(y){min((q[,x]*skills[y,])[(q[,x])>0])})})
  mx.s <- matrix(sapply(mx, function(i) sample(0:1, 1,   prob=c(1-i,  i))), sts, its)
  results <- list(mx.s,skills,q)
  names(results) <- c('results','skills.matrix','q.matrix')
  return(results)
}



#' Performance data generation according to an average approach. Linear model.
#'
#' This function generates students' performance data according to a Q-matrix sampling model where more than one skill can be required to succeed an item. \cr
#' Given a set of skills involved in the set of items, there is a matrix where each element represents the probability of a student to suceed an item which involves the correspondent skill. It's a students per skills matrix.[0-1] values.  \cr
#' According to the information provided by the Q-Matrix, if an item requires 2 skills, the probability of a student to answer correctly to that item will be the root mean square of the probabilities of this student to succeed items involving both skills.
#'
#' @param its Number of items.
#' @param sts Number of students.
#' @param rank Number of skills the set of items has.
#' @param q Q-Matrix representing the skills required to succeed an item. skills per item matrix.{0,1} values. NULL by default.
#' @param skills Matrix representing the probability of each student to answer correctly to an item involving a specific skill. students per skills matrix.[0-1] values. NULL by default.
#' @param mean If the skills matrix is not provided to the function, this parameter is the mean used to generate that matrix according to the standard distribution. 0 by default.
#' @param deviation If the skills matrix is not provided to the function, this parameter is the standard deviation used to generate that matrix according to the standard distribution. 1 by default. 
#' 
#' @return A list with the following information:
#'  \item{results}{Students per items matrix where each element represents if the student answered correctly (1) or not (0) to the correspondent item.}
#'  \item{skills.matrix}{A student per skill matrix where each element represents the probability of a student to answer correctly to an item that involves the correspondent skill.}
#'  \item{q.matrix}{The Q-matrix used.}
#'  
#' @seealso 
#'  \code{\link{QgenInc}} for the external generation of a Q-matrix.\cr
#'  \code{\link{QgenReg}} for the external generation of a Q-matrix.\cr
#'  \code{\link{extendQ}} for the external generation of a Q-matrix.\cr
#'  \code{\link{reduceQ}} for the external generation of a Q-matrix.\cr
#'  \code{\link{skillsGen}} for the external generation of the skills matrix.\cr
#'  
#' @examples
#' 
#'  #####EXAMPLE 1 : Generation introducing the minimum number of parameters required #####
#'  
#'  # We generate student performance data about 3 students answering to 5 items and 3 skills.
#'  result <- avgGen(its = 5, sts = 3, rank = 3)
#'  
#'  # We extract the correspondent information
#'  
#'  performance  <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    0    0    1
#'  [2,]    1    0    0    0    0
#'  [3,]    1    0    1    1    1
#'  
#'  skills  <- result$skills.matrix
#'  skills
#'          [,1]      [,2]      [,3]
#'  [1,] 0.5659460 0.7730670 0.1510989
#'  [2,] 0.2754485 0.3557638 0.5745654
#'  [3,] 0.0414596 0.1636330 0.9992421
#'  
#'  q.matrix  <- result$q.matrix
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    1    1    0    1    0
#'  [2,]    1    1    0    1    1
#'  [3,]    1    0    1    1    1
#'
#' #####EXAMPLE 2 : Generation modeling the mean and the standard deviation used #####
#' 
#'  # We generate student performance data about 3 students answering to 5 items and 3 skills.
#'  #For the stantard distribution (skills matrix), we use a mean of 0.5 and a standard deviation of 0.2.
#'  result <- minGen(its = 5, sts = 3, rank = 3,mean=0.5,deviation=0.2)
#'  
#'  # We extract the correspondent information
#'  
#'  performance  <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    1    1    1
#'  [2,]    1    0    0    0    1
#'  [3,]    1    0    1    1    1
#'  
#'  skills  <- result$skills.matrix
#'  skills
#'          [,1]      [,2]      [,3]
#'  [1,] 0.6575190 0.6271332 0.7383802
#'  [2,] 0.7441959 0.5290334 0.6381248
#'  [3,] 0.6988804 0.5926346 0.6011667
#'  
#'  q.matrix  <- result$q.matrix
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    0    1    1    1
#'  [2,]    1    1    0    1    0
#'  [3,]    1    1    1    1    0
#' 
#'  #####EXAMPLE 3 : Generation introducing a Q-matrix #####
#'
#'  #We generate a Q-Matrix with 3 skills involved.
#'  q.matrix <- QgenInc(num.skills = 3,maxSkillsPerItem=2)
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    1    0    0    1    1    0
#'  [2,]    0    1    0    1    0    1
#'  [3,]    0    0    1    0    1    1
#'  
#' # We generate student performance data about 3 students answering to 6 items, 3 skills and the Q Matrix we want.
#' # For the stantard distribution (skills matrix), we use a mean of 0.5 and a standard deviation of 0.2.
#'  result <- minGen(its = 6, sts = 3, rank = 3,q = q.matrix,mean=0.5,deviation=0.2)
#'
#'  # We extract the correspondent information
#'
#'  performance  <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    1    1    0    1    0    1
#'  [2,]    0    0    0    0    1    0
#'  [3,]    1    0    1    0    0    0
#'  
#'  skills  <- result$skills.matrix
#'  skills
#'          [,1]      [,2]      [,3]
#'  [1,] 0.7293017 0.6951063 0.6243320
#'  [2,] 0.8131855 0.6306849 0.7204342
#'  [3,] 0.6953339 0.6937963 0.5450721
#'  
#'  q.matrix  <- result$q.matrix
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    1    0    0    1    1    0
#'  [2,]    0    1    0    1    0    1
#'  [3,]    0    0    1    0    1    1
#' 
#'  #####EXAMPLE 4 : Generation introducing a Q-Matrix and a skills matrix #####
#'  
#'  #We generate a Q-Matrix with 3 skills involved.
#'  q.matrix <- QgenInc(num.skills = 3,maxSkillsPerItem=2)
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    1    0    0    1    1    0
#'  [2,]    0    1    0    1    0    1
#'  [3,]    0    0    1    0    1    1
#'  
#'  #We generate a skills matrix  skills for 3 students, 3 skills, a mean of 0 and a standard deviation of 1.
#'  skills  <- skillsGen(sts = 3,mean = 0,deviation = 1,rank = 3)
#'  skills
#'          [,1]      [,2]      [,3]
#'  [1,] 0.003903748 0.9802114 0.5885409
#'  [2,] 0.900522227 0.3580975 0.4001344
#'  [3,] 0.978809077 0.9618280 0.1626563
#'  
#'  # We generate student performance data about 3 students answering to 6 items, 3 skills and the Q Matrixand skills 
#'  matrix we want.
#'  result <- minGen(its = 6, sts = 3, rank = 3,q = q.matrix,skills = skills)
#'  
#'  # We extract the correspondent information
#'  performance  <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    0    1    1    0    0    1
#'  [2,]    1    1    0    0    0    0
#'  [3,]    1    1    1    1    0    0
#'  
#'  skills  <- result$skills.matrix
#'  skills
#'          [,1]      [,2]      [,3]
#'  [1,] 0.003903748 0.9802114 0.5885409
#'  [2,] 0.900522227 0.3580975 0.4001344
#'  [3,] 0.978809077 0.9618280 0.1626563
#'  
#'  q.matrix  <- result$q.matrix
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    1    0    0    1    1    0
#'  [2,]    0    1    0    1    0    1
#'  [3,]    0    0    1    0    1    1
#
avgGen <- function(its,sts,rank,q=NULL,skills = NULL,mean = 0, deviation = 1){
  if(is.null(skills)){
    skills <- skillsGen(sts=sts,mean=mean,deviation=deviation,rank=rank)
  }
  if(is.null(q)){
    q <- QgenInc(rank,rank)
    if(its < ncol(q)){
      q <- reduceQ(q,its)
    }
    else if(its > ncol(q)){
      q <- extendQ(q,(its-ncol(q)))
    }
  }
  
  mx <- sapply(1:its,function(x){sapply(1:sts,function(y){sqrt(sum((q[,x]*skills[y,])^2)/sum(q[,x][q[,x]!=0]))})})
  mx.s <- matrix(sapply(mx, function(i) sample(0:1, 1,   prob=c(1-i,  i))), sts, its)
  results <- list(mx.s,skills,q)
  names(results) <- c('results','skills.matrix','q.matrix')
  return(results)
}


#' Generation according to the DINA/DINO model.
#'
#' This function generates the students' performance data according to a Q-matrix sampling model where more than one skill can be required to succeed an item. \cr
#' Given a set of skills involved in the set of items, there is a matrix where each element represents the probability of a student mastering the correspondent skill. It's a students per skills matrix. \{0,1\} values.  \cr
#' According to the information provided by the Q-Matrix, if an item requires 2 skills, the probability of a student to answer correctly to that item will depend on the model chosen and the skills the student masters.\cr
#' If the DINA model is chosen and the student masters both skills, he will answer wrong with a probability corresponding to the slip value proper to this item. Otherwise, if he doesn't master both skills, he will get a  chance to answer right corresponding to the guess parameter. \cr
#' If the DINO model is chosen and the student masters one of both skills, he will answer wrong with a probability corresponding to the slip value proper to this item. Otherwise, if he doesn't master any of the skills involved, he will get a chance to answer right corresponding to the guess parameter.
#'
#' @param its Number of items.
#' @param sts Number of students.
#' @param rank Number of skills the set of items has.
#' @param q Q-Matrix representing the skills required to succeed an item. Skills per item matrix.{0,1} values. NULL by default.
#' @param guess A vector with the guess parameter for each item. If the student doesn't master the skills required to succeed the correspondent item, the probability of succeeding that item will be the guess value corresponding to this item. 0.2 by default.
#' @param slip A vector with the slip parameter for each item. If the student master the skills required to succeed the correspondent item, the probability of answering wrong to that item will be the slip value corresponding to this item. Same as the guess parameter by default.
#' @param skills Matrix representing the probability of each student to answer correctly to an item involving a specific skill. Students per skills matrix.This matrix will help to generate the skills mastery matrix. A probability above 0.5 will be considered as mastering the skill.[0-1] values. NULL by default.
#' @param mean If the skills matrix is not provided to the function, this parameter is the mean used to generate that matrix according to the standard distribution. 0 by default.
#' @param deviation If the skills matrix is not provided to the function, this parameter is the standard deviation used to generate that matrix according to the standard distribution. 1 by default. 
#' @param model Model chosen between 'DINA' and 'DINO'. 'DINA' by default.
#' 
#' @return A list with the following information:
#'  \item{results}{Students per items matrix where each element represents if the student answered correctly (1) or not (0) to the correspondent item.}
#'  \item{skills.mastery}{A student per skill matrix where each element represents if a student masters a skill or not.}
#'  \item{q.matrix}{The Q-matrix used.}
#'  
#' @seealso 
#'  \code{\link{QgenInc}} for the external generation of a Q-matrix.\cr
#'  \code{\link{QgenReg}} for the external generation of a Q-matrix.\cr
#'  \code{\link{extendQ}} for the external generation of a Q-matrix.\cr
#'  \code{\link{reduceQ}} for the external generation of a Q-matrix.\cr
#'  \code{\link{skillsGen}} for the external generation of the skills matrix.\cr
#' @references
#' \url{http://cran.r-project.org/web/packages/CDM/}
#' @examples
#' 
#'  #####EXAMPLE 1 : Generation introducing the minimum number of parameters required (DINA model) #####
#'  
#'  # We generate student performance data about 3 students answering to 5 items and 3 skills. DINA model.
#'  result <- dinGen(its = 5,sts = 3,rank = 3)
#'  
#'  # We extract the correspondent information
#'  
#'  performance <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    1    1    0    0    1
#'  [2,]    0    0    1    0    1
#'  [3,]    0    0    1    1    0
#'  
#'  skills.mastery  <- result$skills.mastery
#'  skills.mastery
#'        [,1] [,2] [,3]
#'  [1,]    1    1    0
#'  [2,]    1    0    1
#'  [3,]    0    1    1
#'  
#'  q.matrix  <- result$q.matrix
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    0    0    1
#'  [2,]    1    1    0    0    0
#'  [3,]    0    0    1    1    1
#'  
#'  
#'  #####EXAMPLE 2 : Generation modeling the skills matrix parameters (skills mastery matrix) (DINO model)#####
#'  
#'  # We generate student performance data about 3 students answering to 5 items and 3 skills. DINO model.
#'  #For the stantard distribution (skills matrix), we use a mean of 0.5 and a standard deviation of 0.2.
#'  result <- dinGen(its = 5,sts = 3,rank = 3,mean = 0.5,deviation = 0.2,model = 'DINO')
#'  
#'  # We extract the correspondent information
#'  
#'  performance <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    1    0    1    1    0
#'  [2,]    1    1    0    1    1
#'  [3,]    1    0    1    1    1
#'  
#'  skills.mastery  <- result$skills.mastery
#'  skills.mastery
#'      [,1] [,2] [,3]
#'  [1,]    1    1    1
#'  [2,]    1    1    1
#'  [3,]    1    1    1
#'  
#'  q.matrix  <- result$q.matrix
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    0    1    1    0
#'  [2,]    0    0    0    1    0
#'  [3,]    1    1    0    0    1
#'  
#'  #####EXAMPLE 3 : Generation introducing a Q-Matrix (DINA model)#####
#'  
#'  #We generate a Q-Matrix with 3 skills involved.
#'  q.matrix <- QgenInc(num.skills = 3, maxSkillsPerItem = 3)
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7]
#'  [1,]    1    0    0    1    1    0    1
#'  [2,]    0    1    0    1    0    1    1
#'  [3,]    0    0    1    0    1    1    1
#'  
#'  # We generate student performance data about 3 students answering to 7 items and 3 skills. DINA model.
#'  result <- dinGen(its = 7,sts = 3,rank = 3,q = q.matrix)
#'  
#'  # We extract the correspondent information
#'  
#'  performance <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7]
#'  [1,]    1    0    0    0    0    0    0
#'  [2,]    0    0    1    0    0    0    1
#'  [3,]    1    1    1    1    0    1    1
#'  
#'  skills.mastery  <- result$skills.mastery
#'  skills.mastery
#'        [,1] [,2] [,3]
#'  [1,]    1    1    0
#'  [2,]    0    1    0
#'  [3,]    1    1    1
#'  
#'  q.matrix  <- result$q.matrix
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7]
#'  [1,]    1    0    0    1    1    0    1
#'  [2,]    0    1    0    1    0    1    1
#'  [3,]    0    0    1    0    1    1    1
#'  
#'  
#'  #####EXAMPLE 4 : Generation introducing a Q-Matrix and a skills mastery matrix(DINO model)#####
#'  
#'  #We generate a Q-Matrix with 3 skills involved.
#'  q.matrix <- QgenInc(num.skills = 3, maxSkillsPerItem = 3)
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7]
#'  [1,]    1    0    0    1    1    0    1
#'  [2,]    0    1    0    1    0    1    1
#'  [3,]    0    0    1    0    1    1    1
#'  #We generate a skills matrix  skills for 3 students, 3 skills, a mean of 0 and a standard deviation 
#'  of 1.
#'  skills  <- skillsGen(sts = 3,mean = 0,deviation = 1,rank = 3)
#'  skills
#'          [,1]      [,2]      [,3]
#'  [1,] 0.8362343 0.5610519 0.9333690
#'  [2,] 0.7390838 0.8986089 0.6403717
#'  [3,] 0.3655802 0.7970677 0.3658878
#'  
#'  # We generate student performance according to the Q-matrix and de skills matrix generated. 
#'  DINO model.
#'  result <- dinGen(its = 7,sts = 3,rank = 3,q = q.matrix,skills=skills,model='DINO')
#'  
#'  # We extract the correspondent information
#'  
#'  performance <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7]
#'  [1,]    0    1    0    0    1    0    1
#'  [2,]    1    1    1    1    1    0    0
#'  [3,]    0    1    0    0    0    1    1
#'  
#'  skills.mastery  <- result$skills.mastery
#'  skills.mastery
#'        [,1] [,2] [,3]
#'  [1,]    1    1    1
#'  [2,]    1    1    1
#'  [3,]    0    1    0
#'  
#'  q.matrix  <- result$q.matrix
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7]
#'  [1,]    1    0    0    1    1    0    1
#'  [2,]    0    1    0    1    0    1    1
#'  [3,]    0    0    1    0    1    1    1
#
dinGen <- function(its,sts,rank,q=NULL,guess = rep(0.2,nrow(q)),slip = guess, skills = NULL,mean = 0,deviation = 1,model = 'DINA'){
  require(CDM)
  if(is.null(q)){
    q <- QgenInc(rank,rank)
    if(its < ncol(q)){
      q <- reduceQ(q,its)
    }
    else if(its > ncol(q)){
      q <- extendQ(q,(its-ncol(q)))
    }
  }
  if(is.null(skills)){
    skills <- skillsGen (sts,mean,deviation,nrow(q)) 
  }
  
  skills.mastery  <- matrix(sapply(skills,function(i) 
                            if(i >= 0.5){
                              i=1
                            }
                            else{
                              i=0
                            }),sts,nrow(q))  
  
  mx.s  <- matrix(sim.din(q.matrix = t(q), guess = guess,slip=slip,rule=model,alpha=skills.mastery)$dat,sts,ncol(q))
  results <- list(mx.s,skills.mastery,q)
  names(results) <- c('results','skills.mastery','q.matrix')
  return(results)
}




#' Generation according to the IRT model.
#'
#'This function generates students' performance data according to the IRT model. There is no Q-matrix or skills matrix involved.\cr
#'Each item has a difficulty 'b' and a discrimination parameter 'a'. IRT assumes that the probability of success to an item X_j is a function of a single ability factor \eqn{\theta} :
#'\deqn{P(X_j = 1 | \theta) = ( 1 / (1 + e^(-a_j * (\theta - b_j) ) ) ) }
#'The ability of each student is generated using the normal distribution with parameters that can be modeled. It's normalized between -4 and 4.\cr
#'The items' difficulties will be generated according to the normal distribution with modifiables parameters as well. It's normalized between -3 and 3.\cr
#'However, a students' performance matrix,representing the success or failure of a set of students to a set of items, can be provided so as the abilities and item difficulty matrices can be generated learning from that given matrix.\cr
#'\cr
#' Moreover, there is also the possibility of introducing a slip and guess noise. In that case an expected success (1) could become a failure (0) depending on the slip parameter.
#'In the same way, an expected failure (0) could become a success (1) depending on the guess parameter.
#'
#' @param its Number of items.
#' @param sts Number of students.
#' @param result Students' performance matrix where each element represents if a student i has answered correctly (1) or not (0) to an item j. NULL by default.
#' @param meanAb If the results matrix is not provided. The abilities matrix will be generated according to the standard distribution with this parameter as the mean. 0 by default.
#' @param sdAb If the results matrix is not provided. The abilities matrix will be generated according to the standard distribution with this parameter as the standard deviation. Since the abilities matrix is a [-4,4] matrix, this parameter takes the value 2.5 by default.
#' @param maxAb If the results matrix is not provided. The abilities matrix will be generated according to the standard distribution.with this parameter as the mean. This parameter is the maximum ability allowed for a student .2.5 by default.
#' @param minAb If the results matrix is not provided. The abilities matrix will be generated according to the standard distribution.with this parameter as the mean. This parameter is the minimum ability allowed for a student .-2.5 by default.
#' @param meanDiffIt If the results matrix is not provided. The items' difficulty matrix will be generated according to the standard distribution with this parameter as the mean. 0 by default.
#' @param sdDiffIt If the results matrix is not provided. The items' difficulty matrix will be generated according to the standard distribution with this parameter as the standard deviation. Since the abilities matrix is a [-3,3] matrix, this parameter takes the value 1 by default.
#' @param maxDiffIt If the results matrix is not provided. The abilities matrix will be generated according to the standard distribution with this parameter as the mean. This parameter is the maximum item difficulty allowed. 2.5 by default.
#' @param minDiffIt If the results matrix is not provided. The abilities matrix will be generated according to the standard distribution with this parameter as the mean. This parameter is the minimum item difficulty allowed. 2.5 by default.
#' @param meanDisc The items' discrimination matrix will be generated according to the normal distribution with the value of this parameter as the mean. 0 by default.
#' @param sdDisc The items' discrimination matrix will be generated according to the normal distribution with the value of this parameter as the standard deviation. 1 by default.
#' @param guess Even though according to the IRT approach the student has answered correctly to an item. The user can introduce a slip parameter.
#' @param slip Even though according to the IRT approach the student hasn't answered correctly to an item. The user can introduce a guess parameter.
#' 
#' @return A list with the following information:
#'  \item{results}{Students per items matrix where each element represents if the student answered correctly (1) or not (0) to the correspondent item.}
#'  \item{student.avg.ability}{An ability per student matrix where each element represents the ability of a student.}
#'  \item{item.difficulty}{A difficulty per item matrix where each element represents the difficulty of an item.}
#'  
#' @seealso 
#'  \code{\link{randGen}} for the external students' performance data from which this function can learn.\cr
#'  \code{\link{minGen}} for the external students' performance data from which this function can learn.\cr
#'  \code{\link{avgGen}} for the external students' performance data from which this function can learn.\cr
#'  \code{\link{dinGen}} for the external students' performance data from which this function can learn.\cr
#'  \code{\link{irtGen}} for the external students' performance data from which this function can learn.\cr
#'  \code{\link{poksGen}} for the external students' performance data from which this function can learn.\cr
#' 
#' @references
#' Beheshti, B. and Desmarais, M. C. (2014). Assessing model fit with synthetic vs. real data. Polytechnique Montreal.
#' 
#' @examples
#' 
#'  #####EXAMPLE 1 : Generation introducing the minimum number of parameters required #####
#'  
#'  #We generate data for 3 students and 5 items.
#'  result = irtGen(its = 5, sts = 3)
#'  
#'  # We extract the correspondent information
#'  
#'  performance  <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    0    0    1
#'  [2,]    0    0    0    1    1
#'  [3,]    0    0    0    0    0
#'  
#'  abilities  <- result$student.avg.ability
#'  abilities
#'          [,1]       [,2]       [,3]
#'  [1,] -2.211515 -0.1775592 -0.6316655
#'
#'  difficulties  <- result$item.difficulty
#'  difficulties
#'          [,1]      [,2]      [,3]       [,4]      [,5]
#'  [1,] 0.3132829 0.1178107 0.5078971 -0.5025616 -0.439553
#'
#'  #####EXAMPLE 2 : Generation introducing a students' performance matrix as reference #####
#'  
#'  #We generate a students' performance data according to the IRT model.
#'  reference  <- irtGen(sts = 3, its = 20)$result
#'  reference
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] [,15] [,16] 
#'  [1,]    1    1    1    1    1    1    1    0    1     1     1     0     0     0     1   ...  
#'  [2,]    0    0    0    1    1    0    1    0    1     0     0     0     0     1     1   ...  
#'  [3,]    0    0    0    1    1    0    1    0    1     0     0     0     1     1     0   ...  
#'  
#'  #We generate data for 3 students and 20 items. A reference matrix is provided to learn about
#'  the students abilities and the items difficulties.
#'  result  <-  irtGen(its = 20, sts = 3,result = reference)
#'  
#'  # We extract the correspondent information
#'  performance  <- result$results
#'  performance
#'        [,1] [,2] [,3]
#'  [1,]    1    0    1
#'  [2,]    1    0    0
#'  [3,]    0    1    0
#'  
#'  abilities  <- result$student.avg.ability
#'  abilities
#'        [,1] [,2] [,3]
#'  [1,]    0 -2.4    2
#'  
#'  difficulties  <- result$item.difficulty
#'  difficulties
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] [,15] [,16] 
#'  [1,]   -1   -1   -1    3    3   -1    3   -3    3    -1    -1    -3    -1     1     1   ...
#'  
#'  
#
irtGen <- function(its,sts,result = NULL,meanAb=0,sdAb=1.5,maxAb=2.75,minAb=-2.75,meanDifIt=0,sdDifIt=1,maxItDif = 2.5,minItDif=-2.5,meanDisc=1,sdDisc=0,guess=0.2,slip=0.2){
  
  if(!is.null(result)){
    
    abilities <- double(nrow(result))
    abilities <- sapply(1:nrow(result),function(x){abilities[x]  <-  ((length(result[x,][result[x,] == 1]))/(ncol(result)))})
    abilities <- sapply(abilities,function(x){x  <-  ((x - 0) / 1 * (4-(-4)) + (-4))})

    difficulties <- double(ncol(result))
    difficulties <- sapply(1:ncol(result),function(x){difficulties[x]  <-  ((length(result[,x][result[,x] == 0]))/(nrow(result)))})
    difficulties <- sapply(difficulties,function(x){x  <-  ((x - 0) / 1 * (3-(-3)) + (-3))})
  }
  else{
    abilities  <-  rnorm(sts,meanAb,sdAb)

    difficulties = rnorm(its,meanDifIt,sdDifIt)
    
  }
  abilities[which(abilities>maxAb)]<-maxAb
  abilities[which(abilities< minAb)]<- minAb
  
  difficulties[which(difficulties>maxItDif)]<- maxItDif
  difficulties[which(difficulties< minItDif)]<-  minItDif
  
  Disc = rnorm(its,meanDisc,sdDisc)
  
  R1 = round(sapply(1:length(difficulties), function(i) sapply(1:length(abilities), function(j) 1/(1+exp(-1*Disc[i]*(abilities[j]-difficulties[i]))))))
  
  R=R1
  R[R1==1] <- sample(0:1, sum(R1), prob=c(slip, 1-slip), replace=T) # Add slip factor
  R[R1==0] <- sample(1:0, sum(!R1), prob=c(guess, 1-guess), replace=T) # Add guess factor
  
  results <- list(R,t(abilities),t(difficulties))
  names(results) <- c('results','student.avg.ability','item.difficulty')
  return(results)
}

#' Generation according to the POKS model.
#'
#' In this model, there is a matrix of items per items that represents the dependencies between items. It's called poks matrix and it gives the Partial Orders Knowledge Structure (POKS).
#' Meaning that, if a student answer correctly to an item B, he will have a higher chance to succeed items related to B but easier.
#' That can be modeled as \eqn{P(A|B) = p1}. It's a \{0,1\} matrix where a 1 in the position (i,j) means that suceeding the item i increases the possibilities of succeeding the item j.\cr
#' When there is no knowledge about an item, the probability of succeeding this item will depends on the student's success rate. This rate can be learned providing a students' performance matrix to the function.
#' Otherwise, it will be generated according to the normal distribution normalized to [0-1] values.
#'
#' @param its Number of items.
#' @param sts Number of students.
#' @param dependencies The poks matrix. NULL by default
#' @param results A students' performance matrix from which the function learns to generate the students' success rate matrix.
#' @param success.avg Matrix with the success rate of each student.
#' @param p1 Probability of succeeding an item having succeeded a more difficult one related to it.
#' @param mean If the results matrix is not provided to the function, the students' success rate matrix will be generated according to the normal function with this parameter as the mean value. 0 by default.
#' @param deviation If the results matrix is not provided to the function, the students' success rate matrix will be generated according to the normal function with this parameter as the standard deviation value. 1 by default.
#' 
#' @return A list with the following information:
#'  \item{results}{Students per items matrix where each element represents if the student answered correctly (1) or not (0) to the correspondent item.}
#'  \item{poks.matrix}{The matrix that matches each item with the items that depend on itself.}
#'  \item{success.avg}{A matrix with the success average of each student}
#'  
#' @seealso 
#'  \code{\link{randGen}} for the external students' performance data from which this function can learn.\cr
#'  \code{\link{minGen}} for the external students' performance data from which this function can learn.\cr
#'  \code{\link{avgGen}} for the external students' performance data from which this function can learn.\cr
#'  \code{\link{dinGen}} for the external students' performance data from which this function can learn.\cr
#'  \code{\link{irtGen}} for the external students' performance data from which this function can learn.\cr
#'  \code{\link{poksGen}} for the external students' performance data from which this function can learn.\cr
#'  \code{\link{poksMatrixGen}} for the external students' performance data from which this function can learn.\cr
#' 
#' @references
#' Beheshti, B. and Desmarais, M. C. (2014). Assessing model fit with synthetic vs. real data.
#' 
#' @examples
#' 
#'  #####EXAMPLE 1 : Generation introducing the minimum number of parameters required #####
#'  
#'  #We generate data for 3 students and 5 items. The probability P(A|B) = 0.85
#'  result <- poksGen(its = 5, sts = 3, p1 = 0.85)
#'  
#'  # We extract the correspondent information
#'  
#'  performance  <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    1    0    0
#'  [2,]    0    1    1    0    0
#'  [3,]    1    1    1    1    1
#'  
#'  poks.matrix   <- result$poks.matrix
#'  poks.matrix
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    0    1    1
#'  [2,]    0    0    1    0    0
#'  [3,]    0    0    0    0    0
#'  [4,]    0    0    0    0    0
#'  [5,]    0    0    0    0    0
#'  
#'  success.avg  <- result$success.avg
#'  success.avg
#'          [,1]     [,2]      [,3]
#'  [1,] 0.2933311 0.419173 0.5056854
#'
#'
#'  #####EXAMPLE 2 : Generation introducing a students' performance matrix as reference and an 
#'  external poks matrix#####
#'  
#'  #We generate the students' performance data form which we want to learn
#'  reference <- poksGen(its = 20, sts = 3, p1 = 0.85)$result
#'  reference
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] [,15] [,16] 
#'  [1,]    0    0    0    0    0    0    0    0    0     0     0     0     0     0     0   ...  
#'  [2,]    0    0    0    0    0    0    0    0    0     0     0     0     0     0     0   ...  
#'  [3,]    0    1    1    0    0    1    1    1    1     1     0     1     1     1     0   ...
#'  
#'  #We generate an external poks matrix
#'  poks.matrix  <- poksMatrixGen(its = 8, depNum = 5, trees = 2, indirect.dependencies = TRUE)
#'  poks.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
#'  [1,]    0    1    0    1    0    0    0    0
#'  [2,]    0    0    1    0    0    0    0    0
#'  [3,]    0    0    0    0    0    0    0    0
#'  [4,]    0    0    0    0    0    0    0    0
#'  [5,]    0    0    0    0    0    1    1    0
#'  [6,]    0    0    0    0    0    0    0    0
#'  [7,]    0    0    0    0    0    0    0    0
#'  [8,]    0    0    0    0    0    0    0    0
#'  
#'  #We generate the data according to the parameters generated
#'  result <- poksGen(its = 8, sts = 3 , dependencies = poks.matrix, result = reference,p1 = 0.85)
#'
#'  # We extract the correspondent information
#'  
#'  performance  <- result$results
#'  performance
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
#'  [1,]    0    0    0    0    0    0    0    0
#'  [2,]    0    0    0    0    0    0    0    0
#'  [3,]    0    0    0    1    1    1    1    1
#'
#'  poks.matrix   <- result$poks.matrix
#'  poks.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
#'  [1,]    0    1    0    1    0    0    0    0
#'  [2,]    0    0    1    0    0    0    0    0
#'  [3,]    0    0    0    0    0    0    0    0
#'  [4,]    0    0    0    0    0    0    0    0
#'  [5,]    0    0    0    0    0    1    1    0
#'  [6,]    0    0    0    0    0    0    0    0
#'  [7,]    0    0    0    0    0    0    0    0
#'  [8,]    0    0    0    0    0    0    0    0
#'  
#'  success.avg  <- result$success.avg
#'  success.avg 
#'        [,1] [,2] [,3]
#'  [1,]    0    0  0.65
#'   
#
poksGen  <- function(its,sts,dependencies = NULL,result = NULL,success.avg=NULL,p1,mean = 0,deviation= 1){
  if(is.null(dependencies)){
    dependencies <- poksMatrixGen(its,(its-round(its/5)),round(its/5),indirect.dependencies = TRUE)
  }
  if(is.null(success.avg)){
    if(is.null(result)){
      success.avg  <- pnorm(rnorm(sts,mean=mean,sd=deviation))
    }
    else {
      success.avg <- double(nrow(result))
      success.avg <- sapply(1:nrow(result),function(x){success.avg[x]  <-  ((length(result[x,][result[x,] == 1]))/(ncol(result)))})
    }  
  }
  ##################results matrix generation#################
  result  <- matrix(0,sts,its)
  for(w in 1:its){
    for (t in 1:sts){
      if(result[t,w] == 0){
        result[t,w]  <-  sample(0:1,1,prob= c(1-success.avg[t],success.avg[t]))
      }
      if(result[t,w] == 1){
        aux  <-  dependencies[w,w:its]
        aux  <-  sapply(aux,function(i){if(i==1){i  <-  sample(0:1,1,prob= c(1-p1,p1))}else{i=0}})
        result[t,w:its]  <-  result[t,w:its] + aux
      }
    }
  }
  result[which(result > 1)]  <-  1
  results <- list(result,dependencies,t(success.avg))
  names(results) <- c('results','poks.matrix','success.avg')
  return(results) 
}





###########################PARAMETERS GENERATION############################


###################Q-MATRIX GENERATION#########################
#' Q-matrix generation with the same number of skills required per item.
#'
#' Q-matrix with dimensions corresponding to all the combinations of items involving the number of skills per item defined.
#' In this function, all the items have the the same number of skills involved. 
#'
#' @param num.skills Number of skills involved.
#' @param skillsPerItem Number of skills per item.
#' 
#' @return 
#'  \item{q}{Q matrix with the information about the skills required to succeed each item. Skills per items matrix.}
#'  
#' @seealso
#'  \code{\link{minGen}} for the external Q-Matrix that can be provided to this function.\cr
#'  \code{\link{avgGen}} for the external Q-Matrix that can be provided to this function.\cr
#'  \code{\link{dinGen}} for the external Q-Matrix that can be provided to this function.\cr
#'  
#' @examples
#'  
#'  #We generate a Q-matrix with 4 skills involved and 2 skills involved per item.
#'  q.matrix <- QgenReg(num.skills = 4, skillsPerItem = 2)
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    1    1    1    0    0    0
#'  [2,]    1    0    0    1    1    0
#'  [3,]    0    1    0    1    0    1
#'  [4,]    0    0    1    0    1    1
#
QgenReg <- function(num.skills, skillsPerItem){
  
    c <- combn(num.skills,skillsPerItem)
    columns <- length(c)/skillsPerItem
    q <- matrix(0,num.skills,columns)
    for(i in 1:columns){
      for(j in 1:skillsPerItem){
        if(num.skills == skillsPerItem){
          q[c[j],i] <- 1
        }
        else{
          q[c[j,i],i] <- 1
        }
      }
    }
  
  return(q)
}


#' Q-matrix generation with a variable number of skills required per item.
#'
#' Q-matrix generation where the number of items depends on the maximum number of skills per item chosen. 
#' If we define 3 skills involved in the whole set of items, and we want the most difficult item to require 2 skills, we will have a number of items corresponding to all the combinations of 1 skill per item and all the combinations of 2 skills per item.
#' In case we want to set the most difficult item to involve the 3 skills, our Q-matrix would include a last column corresponding to an item involving all the skills.
#'
#' @param num.skills Number of skills involved.
#' @param maxSkillsPerItem Maximum number of skills required to succeed an item. It represents the maximum difficulty of an item.
#' 
#' @return 
#'  \item{q}{Q matrix with the information about the skills required to succeed each item. Skills per items matrix.}
#'  
#' @seealso
#'  \code{\link{minGen}} for the external Q-Matrix that can be provided to this function .\cr
#'  \code{\link{avgGen}} for the external Q-Matrix that can be provided to this function.\cr
#'  \code{\link{dinGen}} for the external Q-Matrix that can be provided to this function.\cr
#'  
#' @examples
#'  
#'  #We generate a Q-matrix with 4 skills involved and maximum 3 skills involved per item.
#'  q.matrix <- QgenInc(num.skills = 4, maxSkillsPerItem = 3)
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
#'  [1,]    1    0    0    0    1    1    1    0    0     0     1     1     1     0
#'  [2,]    0    1    0    0    1    0    0    1    1     0     1     1     0     1
#'  [3,]    0    0    1    0    0    1    0    1    0     1     1     0     1     1
#'  [4,]    0    0    0    1    0    0    1    0    1     1     0     1     1     1
#
QgenInc <- function(num.skills, maxSkillsPerItem){
  x <- QgenReg(num.skills,1)
  for(i in 2:maxSkillsPerItem){
    x <- cbind(x,QgenReg(num.skills,i))
  }
  return(x)
}


#' Q-matrix extension.
#'
#' This function increases the number of items of a Q-Matrix randomly repeating some of its columns. It adds the number of items (columns) introduced as  a parameter.
#'
#' @param q Q-matrix to extend.
#' @param extraItems Number of items(columns) to add to the Q-Matrix
#' 
#' @return 
#'  \item{q}{Q matrix with the information about the skills required to succeed each item. Skills per items matrix.}
#'  
#' @seealso
#'  \code{\link{QgenReg}} for the generation of a Q-Matrix .\cr
#'  \code{\link{QgenInc}} for the generation of a Q-Matrix .\cr
#'  \code{\link{reduceQ}} to modify the size of the a Q-matrix.\cr
#' @examples
#'  
#'  #We generate a Q-matrix with 4 skills involved and 3 skills as maximum involved per item.
#'  q.matrix <- QgenInc(num.skills = 4, maxSkillsPerItem = 3)
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
#'  [1,]    1    0    0    0    1    1    1    0    0     0     1     1     1     0
#'  [2,]    0    1    0    0    1    0    0    1    1     0     1     1     0     1
#'  [3,]    0    0    1    0    0    1    0    1    0     1     1     0     1     1
#'  [4,]    0    0    0    1    0    0    1    0    1     1     0     1     1     1
#'  
#'  # We add 2 more items
#'  new.qmatrix <- extendQ(q = q.matrix, extraItems = 2)
#'  new.qmatrix
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] [,15] [,16] 
#'  [1,]    1    0    0    0    1    1    1    0    0     0     1     1     1     0     1     1  
#'  [2,]    0    1    0    0    1    0    0    1    1     0     1     1     0     1     0     1  
#'  [3,]    0    0    1    0    0    1    0    1    0     1     1     0     1     1     0     0  
#'  [4,]    0    0    0    1    0    0    1    0    1     1     0     1     1     1     0     1  
#' 
#
extendQ  <- function(q,extraItems){
  for(i in 1:extraItems){
    rand <- sample(1:dim(q)[2],1)
    q <- cbind(q,q[,rand])
  }
  return(q)
}




#' Q-matrix reduction.
#'
#' This function reduces the size of a Q-Matrix randomly extracting the columns (number of items) needed.
#'
#' @param q Q-matrix to reduce in size.
#' @param numberOfOtems Number of items(columns) of the final Q-Matrix
#' 
#' @return 
#'  \item{q}{Q matrix with the information about the skills required to succeed each item. Skills per items matrix.}
#'  
#' @seealso
#'  \code{\link{QgenReg}} for the generation of a Q-Matrix .\cr
#'  \code{\link{QgenInc}} for the generation of a Q-Matrix .\cr
#'  \code{\link{extendQ}} to modify the size of the a Q-matrix.\cr
#'  
#' @examples
#'  
#'  #We generate a Q-matrix with 4 skills involved and 3 skills as maximum involved per item.
#'  q.matrix <- QgenInc(num.skills = 4, maxSkillsPerItem = 3)
#'  q.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
#'  [1,]    1    0    0    0    1    1    1    0    0     0     1     1     1     0
#'  [2,]    0    1    0    0    1    0    0    1    1     0     1     1     0     1
#'  [3,]    0    0    1    0    0    1    0    1    0     1     1     0     1     1
#'  [4,]    0    0    0    1    0    0    1    0    1     1     0     1     1     1
#'  
#'  # We generate a matrix of just 10 items
#'  new.qmatrix <- reduceQ(q = q.matrix, numberOfItems = 10)
#'  new.qmatrix
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
#'  [1,]    1    0    0    1    1    1    0    0    1     1
#'  [2,]    0    1    1    0    1    0    1    0    0     0
#'  [3,]    1    0    0    1    1    0    1    1    1     1
#'  [4,]    0    1    1    1    0    1    0    1    1     1
#' 
#' 
reduceQ <- function(q,numberOfItems){
  x <- matrix(0,dim(q)[1],numberOfItems)
  for(i in 1:numberOfItems){
    rand <- sample(1:dim(q)[2],1)
    x[,i] <- q[,rand]
  }
  return(x)
}


############################SKILLS GENERATION######################


#' Skills per student matrix generation according to the standard distribution.
#'
#' This function generates a skills per students matrix where each value represents the probability of a student i to answer correctly to an item involving the skill j.
#'
#' @param sts Number of students.
#' @param mean Mean of the standard distribution.
#' @param deviation Standard deviation of the standard distribution.
#' It represents a noise while assigning skills to each student. 
#' @param rank Number of skills the set of items has.
#' 
#' @return 
#'  \item{skills}{The skills per student matrix}
#'  
#' @seealso
#'  \code{\link{minGen}} for the generation of a skills matrix that can be provided to that function.\cr
#'  \code{\link{avgGen}} for the generation of a skills matrix that can be provided to that function.\cr
#'  
#' @examples
#'  
#'  #We generate a skills matrix for 3 students, involving 4 skills, with a mean of 0 and a standard deviation of 1.
#'  skills  <- skillsGen(sts = 3, mean = 0, deviation = 1, rank = 4)
#'  skills
#'          [,1]      [,2]       [,3]      [,4]
#'  [1,] 0.2379563 0.4103992 0.97868219 0.1400159
#'  [2,] 0.7146010 0.7078044 0.59517022 0.4639706
#'  [3,] 0.9454237 0.9641969 0.03825092 0.8487321
#' 
#
skillsGen <- function(sts,mean,deviation,rank){
  skills <- pnorm(matrix(rnorm(sts*rank,mean=mean,sd=deviation),sts,rank))
  return(skills)
}



#' Students per items matrix generation according to the standard distribution.
#'
#' This function generates a matrix with dimensions students*items where each value represents the probability of a student i to success an item j.
#'
#' @param its Number of items.
#' @param sts Number of students.
#' @param mean Mean of the standard distribution.
#' @param deviation Standard deviation of the standard distribution.
#' It represents a noise while assigning skills to each student. 
#' @param rank Number of skills the set of items has.
#' 
#' @return 
#'  \item{succes.prob}{The skills matrix}
#'  
#' @seealso
#'  \code{\link{randGen}} for the generation of a success probability matrix that can be provided to that function.\cr
#'  
#' @examples
#'  
#'  #We generate a success probabilty matrix for 3 students and 5 items, with a mean of 0 and a standard deviation of 1.
#'  success.prob <- successProbGen(its = 5, sts = 3, mean = 0, deviation = 1)
#'  success.prob
#'          [,1]      [,2]      [,3]      [,4]      [,5]
#'  [1,] 0.3657776 0.1630787 0.5882404 0.9314930 0.1885536
#'  [2,] 0.8937646 0.6969860 0.9854258 0.5449783 0.7714228
#'  [3,] 0.9655305 0.5075924 0.1038589 0.4710194 0.7395491
#' 
#
successProbGen <- function(its,sts,mean,deviation){
  success.prob <- pnorm(matrix(rnorm(sts*its,mean=mean,sd=deviation),sts,its))
  return(success.prob)
}

#' POKS matrix generation
#'
#' This function generates the matrix needed by the POKS model. It gives the Partial Orders Knowledge Structure (POKS).
#' Meaning that, if a student answers correctly to an item B, he'll get a higher chance to succeed items related to B but easier.
#' This can be modeled as \eqn{P(A|B) = p1}. It's a \{0,1\} matrix where a 1 in the position (i,j) means that suceeding the item i increases the possibilities of succeeding the item j.\cr
#' In order to generate this matrix, parameters as the total number of dependencies, the number of independent trees or the introduction of indirect dependencies can be modeled.
#' A tree is a partial order structure where succeeding an item, the root, increases the probability of answering correctly to the items that are under it with a direct or indirect dependance.
#' The indirect dependance happens when suceeding an item A increases the possibilities of succeeding item B, and item B increases the possibilities of item C. So, indirectly, item A increases the possibilities of item C.
#' 
#'
#' @param its Number of items.
#' @param depNum The total number of dependencies in the poks matrix. 
#' @param trees The number of independent trees in the poks matrix.
#' @param indirect.dependencies A boolean determining if the poks matrix contains indirect dependencies. FALSE by default
#' 
#' @return 
#'  \item{dependencies}{The poks matrix}
#'  
#' @references
#'  \url{http://cran.r-project.org/web/packages/partitions/index.html}
#'  
#' @seealso
#'  \code{\link{poksGen}} for the generation of data according to the POKS model\cr
#'  
#' @examples
#'  
#'  ##### EXAMPLE 1 : POKS matrix without indirect dependencies #####
#'  #We generate a POKS matrix with 6 items, 2 trees and 4 dependencies.
#'  poks.matrix <- poksMatrixGen(its = 6, depNum = 4,trees = 2)
#'  poks.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6]
#'  [1,]    0    1    1    0    0    0
#'  [2,]    0    0    0    0    0    0
#'  [3,]    0    0    0    0    0    0
#'  [4,]    0    0    0    0    1    1
#'  [5,]    0    0    0    0    0    0
#'  [6,]    0    0    0    0    0    0
#' 
#' ##### EXAMPLE 2 : POKS matrix wit indirect dependencies #####
#'  #We generate a POKS matrix with 8 items, 2 trees and 6 dependencies.
#'  poks.matrix <- poksMatrixGen(its = 8, depNum = 6,trees = 2,indirect.dependencies = TRUE)
#'  poks.matrix
#'        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
#'  [1,]    0    1    0    1    0    0    0    0
#'  [2,]    0    0    1    0    0    0    0    0
#'  [3,]    0    0    0    0    0    0    0    0
#'  [4,]    0    0    0    0    0    0    0    0
#'  [5,]    0    0    0    0    0    1    0    1
#'  [6,]    0    0    0    0    0    0    1    0
#'  [7,]    0    0    0    0    0    0    0    0
#'  [8,]    0    0    0    0    0    0    0    0
#
poksMatrixGen <- function(its,depNum,trees,indirect.dependencies = FALSE){
  require(partitions)
  combinations <- combn(its,2)
  dependencies  <- matrix(0,its,its)
  if(trees == 1){
    dep.tree  <-  depNum;
  }
  else{
    dep.tree <- restrictedparts(depNum,trees)
    dep.tree <- dep.tree[,ncol(dep.tree)]  
  }
  index <- 1
  for(i in 1:trees){
    temp <- combinations[,which(combinations[1,] == index)]
    temp <- matrix(temp,nrow = 2)
    if(dep.tree[i] == 1){
      depths <- 1
    }
    else{
    depths  <-  restrictedparts(dep.tree[i],dep.tree[i])
    depths <- depths[,ncol(depths)]
    }
    if((indirect.dependencies == TRUE) & (dep.tree[i] != 1)){
      depths.rand  <- sample(2:(dep.tree[i]-1),1)
      if((dep.tree[i]-1) == 2){
        depths.rand <- 2
      }
      if((dep.tree[i]) == 2){
        depths.rand <- 2
      }
      depths  <- restrictedparts(dep.tree[i],depths.rand)
      depths <- depths[,ncol(depths)]
    }
    x <- 1
    for(w in depths){
      dependencies[temp[1,x],temp[2,x]]  <-  1
      combinations <- combinations[,-which(combinations[1,]==temp[2,x])]
      aux2 <- temp[2,x]
      ref <- 2
      while((w > 1) & (ref <= w)){
        dependencies[aux2,(aux2+1)]  <-  1
        combinations <- combinations[,-which(combinations[1,]==(aux2+1))]
        temp <- temp[,-which(temp[2,]==(aux2+1))]
        ref <- ref+1
        aux2 <- aux2+1
      }
      x <- x + 1
    }
      index <- (index + dep.tree[i] + 1)
  }
  
  return(dependencies)
}


#' Percentage of similarity between two \{0,1\} matrices.
#'
#' This function returns the performance reached by a \{0,1\} matrix, comparing it to a reference (expected) matrix.
#'
#' @param reference Matrix used as reference.
#' @param result Matrix to analyze its performance or its similarity to the reference matrix.
#' 
#' @return The percentage of similarity comparing element by element
#' 
#' @examples 
#'  x <- randGen(its = 5, sts = 3)$result
#'  x
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    1    0    1
#'  [2,]    0    1    1    1    0
#'  [3,]    0    1    0    1    1
#'  
#'  y <- randGen(its = 5, sts = 3)$result
#'  y
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    1    0    1    1    1
#'  [2,]    1    0    0    0    0
#'  [3,]    0    0    1    0    1
#'  
#'  similarity <- compare(reference = x, result = y)
#'  similarity
#'  [1] 80
#
compare <- function(reference,result){
  x <- 0
  aux <- reference+result
  x <- as.data.frame(table(aux))
  x1 <- x$Freq[3]
  if(is.na(x1)){
    x <- 0
  }
  else{
    x <- x$Freq[2]
  }
  dim <- dim(reference)[1]*dim(reference)[2]
  return(100-((x/dim)*100))
}

#' Bar graph
#'
#' This function generates a bar graph to compare the performance of different approaches.
#'
#' @param results Vector with the values to be compared.
#' @param labels Vector with the names of the values to be plotted.
#' @param col Vector of colors for the bars.
#' 
#' @examples 
#'  x <- randGen(its = 5, sts = 3)$result
#'  x
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    1    0    1
#'  [2,]    0    1    1    1    0
#'  [3,]    0    1    0    1    1
#'  
#'  y <- randGen(its = 5, sts = 3)$result
#'  y
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    0    1    1    1
#'  [2,]    1    0    0    1    1
#'  [3,]    1    0    0    0    0
#'  
#'  z <- randGen(its = 5, sts = 3)$result
#'  z
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    1    1    0    0    1
#'  [2,]    1    0    0    0    0
#'  [3,]    0    1    1    1    1
#'  
#'  result1  <- compare (x,y)
#'  result2  <- compare(x,z)
#'  results  <- c(result1,result2)
#'  labels <- c('y','z')
#'  col <- c('red','green')
#'  barComparison(results,labels,col)
#'  
barComparison <- function(results,labels,col){
  barplot(results,space=0,names.arg=labels,col=col,border="black",xlab="Models",ylab="Performance (%)",ylim = range(pretty(c(0,100))))
}


#' Grid graphic of a matrix.
#'
#' This function represents a matrix under a grid graph. Values closer to 1 will be represented as cells with a color closer to white and values closer to 0 will be cells closer to red.
#'
#' @param data Matrix to be represented.
#' 
#' @examples 
#'  x <- randGen(its = 5, sts = 3)$result
#'  x
#'        [,1] [,2] [,3] [,4] [,5]
#'  [1,]    0    1    1    0    1
#'  [2,]    0    1    1    1    0
#'  [3,]    0    1    0    1    1
#'  
#'  oimage(t(x),xlab='Students',ylab = 'Items')
#
oimage <- function(data, sort=F, ...) {
    if(sort)
    image(1:nrow(data), 1:ncol(data), data[,order(colSums(data))], ...)
    else
    image(x = 1:ncol(data), y = 1:nrow(data), z = t(data),...)
    grid(nx = ncol(data),ny = nrow(data),lty =1,lwd=2,col='black')
}